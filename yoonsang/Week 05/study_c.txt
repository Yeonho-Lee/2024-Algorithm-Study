자료: https://modoocode.com/category/C

(2024-10-17)

<12-1. 포인터는 영희이다! (포인터)>
포인터 = 메모리 상 주소가 저장되는 주소를 저장함


<12-2. 포인터는 영희이다! (포인터)>
상황 1: const int *p = &a;
상황 2: int* const p = &a;
상황 3: int const *p = &a;

에 대해서

a = 4;  // 모든 상황에서 정상 작동
p = &b; // 상황 2에서 오류 발생
*p = 4; // 상황 1, 3에서 오류 발생
으로 이해하면 되나? const 뒤에 붙어있는 (자료형을 제외한) 변수명을 상수처리 하는거라고..
상황 1/3은 const 뒤에 *p가, 상황 2는 const 뒤에 p가 있으니까 위와 같은 결과가 나온다고 이해함
뭔가 야매로 이해하는 기분이라 찜찜...

arr[i] = *(arr + i)


<12-3. 포인터는 영희이다! (포인터)>

int a=4;
int *p=&a;
에서
int *p=a;
도 동일하게 작동함(왜?)

int형에서 변수의 값보다는 포인터가 더 우선하는 듯..
(int)5 + (double)0.66 = (double)5.66
이 되는 식(아님)


int a=4;
int *p=a;
에서 p의 값은 4지만

int a[2]={0,1};
int *p=a;
에서 p의 값은 a의 주소가 됨

a가 단일 값이면 p에 주소 대신 값을 넣는데 a가 배열이면 p에 따로 & 연산자를 안 넣어도 자동으로 주소 값을 넣어줌 <<왜?????
암묵적 변환이라는듯... 그냥 다 바꿔주지


(포인터 정리)
지금까지 정리한 내용을 토대로 이해해보면


p << 변수 값이 담긴 메모리 주소
*p << p가 가리키는 메모리 주소에 실제로 들어있는 값
&p << p의 메모리 주소

(사용 시) &p -> p -> *p
(선언 시) **a -> *a -> a


int a[6]={};
int *p = &a; 
이건 a의 첫 번째 위치 주소를 p에 집어넣고, 포인터 한 칸의 크기를 4바이트로 설정해라
라는 뜻이 됨


int a[6]={};
int *(p)[3] = &a;
이건 a의 첫 번째 위치 주소를 p에 집어넣고, 포인터 한 칸의 크기를 4*3=12바이트로 설정해라
라는 뜻이 됨
(왜 쓰냐? 2차원 배열에 쓰려고)


int a[3][4]={};
int (*p)[2] = a;
이건 a의 첫 번째 위치 주소를 p에 집어넣고, 포인터 한 칸의 크기를 4*2=8바이트로 설정해라
라는 뜻이 됨
근데 이건 warning 띄우고 int (*p)[4]=a; 식으로 해야 warning 안 뜰걸
요컨대 a[a][b]와 (*p)[b] 식으로 해야 warning 안 뜬다는 말임

프로그램에서는 문제 없는데 컴파일러가 님 이거 쓸 때 헷갈리지 않을까? 라고 알려준듯


int (*p)[3] = a;
p       | 0x0     << a의 첫 주소 출력
p+1     | 0xC     << p의 연산크기가 12바이트니까 a의 네 번째 원소 주소 출력
*p+1    | 0x4     << *p의 연산크기는 4바이트이므로 a의 두 번째 원소 주소 출력
*(p+1)  | 0xC     
엄청 까다롭네요; 잠시라도 한 눈 팔면 바로 놓칠 듯



int **pa = &p;
int *p = &a;
int a[6] = {0,1,2,3,4,5};
에서
a는 4바이트, p는 8바이트 가짐

그래서
*(p+1) = 1이지만
*(pa+1) = 2가 됨



int a[21]={1,2,3,4,5...,21};
int **p=a;

에서
*p      는 1을 출력함
*(p+1)  은 3을 출력함(위에서 설명했다)
*p+1    은 5를 출력함 << 이건왜??

int의 크기인 4만큼 늘어난다고 하는데
int *pa=a; *p+1은 2를 잘 출력하잖아

int *pa=a; << pa는 a[0]을 가리키고 연산 +1은 4바이트 움직임
int **p=a; <<  p는 a[0]을 가리키고 연산 +1은 16바이트 움직임

여전히 이해 안 됨
앞으로 int**는 int*만 가리키기로




<13-1. 마술 상자 함수(function)>
다 아는 내용

<13-2. 마술 상자 함수(function)>
포인터의 존재 이유: 함수에 넘겨주려고
ㄴ 그러면 C는 파이썬에 있는 global 구현하려고 이 거대한 진입장벽을 만들었다는 말이냐?
ㄴ 그런듯... 그냥 변수 선언 부분 main 밖으로 빼놓는 식으로 해도 될 듯

(2024-10-21)